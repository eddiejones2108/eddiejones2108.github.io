<!DOCTYPE html>
<html lang="en-UK">

<head>
  <meta charset="utf-8">
  <meta name="author" content="Eddie Jones">
  <meta name="description" content="Some random thoughts on computer science and philosophy">
  <meta name=" viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
  <link rel='stylesheet' type='text/css' href='style.css'>

  <script type='text/javascript', src='script.js'></script>
  <title>Assorted Musings</title>
</head>

<body onload="updateView()" onresize="updateView()" onscroll="updateView()">
  <header>
    <h2>Eddie Jones
      <a href="mailto: ej16147@bristol.ac.uk" class="fa fa-envelope"></a>
      <a href="https://github.com/eddiejones2108" class="fa fa-github"></a>
      <a href="https://www.linkedin.com/in/edward-jones-b59a80151/" class="fa fa-linkedin"></a>
    </h2>

    <h1><a href="index.html#">Assorted Musings</a></h1>
  </header>

  <main>
    <section>
      <h3>Generic Speculation</h3>
      <p>
        There are two principal evalutation stratergies: call-by-value and call-by-name.
        Other spin offs do exist, such as call-by-need, but this dichotomy is the most significant.
        As the name suggest, a call-by-<em>value</em>, or eager, stratergy evaluates the arguments to functions are first fully evaluated and the resulting <em>value</em> is passed to the function.
        On the other hand, call-by-<em>name</em>, or lazy, doesn't evaluate the arguments until they are needed in the body of the function, instead a reference is passed. 
      </p>
      <p>
        But call-by-value also cuts corners.
        It won't evaluate the second argument until the first is finished, pretty lazy if you ask me &#8230;
        Speculative evalutation, doesn't evaluate arguments in sequence but <em>concurrently</em>.
        It is used by the like of facebook when loading and checking lots of resources.
      </p>
    </section>
    
    <section>
      <h4>Selective Functors</h4>
      <p>
        A monad, from the perspective of functional programming, is a way to encapsulating side effects.
        Functions with the same type of side effects can be composed with the bind operator.
        <img class="snippet" src="snippet/monad-class.png"> 
        This operator is funadementally sequential; the side effects produced by the continuation may arbritarily depend on the first parameter.
      </p>
      <p>
        The applicative class is slightly weaker.
        Although it captures a similar notion of effects, it's effects must be <em>independent</em> of what comes before.
        This seperation strengths our compile time knowledge, and we're in a better situation to perform analyses and optimisations such as staging.
        Applicatives are normally presented with an aplication operators (hence the name) but for our purpose the conjunction of <em>parallel</em> effects is more illuminating:
        <img class="snippet" src="snippet/applicative-class.png">      
      </p>
      <p>
        Selective functors, provide a suitable half-way house.
        They are equipped with <em>branching</em> computations, but each branch must be predetermined.
        In otherwords, they have access to the following select combinator which can indeed by evaluated speculatively.
        <img class="snippet" src="snippet/select.png">
        Although <code>Either</code> is techincally enough, it feels a bit clunky, so I decided to write a <em>generic</em> branching combinator that is evaluted speculatively.
      </p>
    </section>

    <section>
      <h4>Generic Programming</h4>
      <p>
        To build this combinator we must first define the generic sum type:
        <img class="snippet" src="snippet/sum.png">    
        
        This generalised algebraic datatype is parameterised by the types of each injection.
        The first constructor allows us use the first injection, and the second allows us to shift injections.
        <code>Right 7 :: Either a Int</code> can now be represented as <code>SS (SZ 7) :: Sum [a, Int]</code>
      </p>
    </section>
  </main>
</body>

</html>